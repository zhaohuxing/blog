---
title: "TCP - 笔记"
date: 2021-05-20T00:00:00+08:00
draft: false
tags: ["TCP"]
---

#### 说一说 TCP 的三次握手？

在 TCP 三次握手的过程中，用到了几个 TCP 首部字段：序号，确认号，确认ACK，同步SYN。

序号：TCP 是面向字节流的，在一个 TCP 连接中，传输的每个字节都是按顺序编号的。序号是指本报文段所发送数据的第一个字节序号。
确认号：期望收到下一段报文的序号。
确认ACK：它是一个标记位，ACK 为 1，视为有效报文；为 0, 视为无效报文。TCP 规定，在连接建立后，所传送的报文段 ACK 必须置为 1。
同步SYN：在连接建立时，用来同步序号。ACK = 0，SYN = 1 这是一个请求建立建立的报文；一个已经建立连接报文中， ACK 和 SYN 都是 1。

客户端的状态变化：关闭，SYN-SEND，连接中。
服务端的状态变化：关闭，SYN-RECV，连接中。

假设有一个客户端 A，服务端 B。服务端 B 通过 TCP 服务器进程先创建传输控制块，准备接受客户进程的连接请求。

1. 客户端 A 向服务端 B 发一个请求建立报文。首部中的同步SYN 字段置为 1，假设序号为 x。该报文不携带数据，但要消耗一个序号。此时客户端进入了 SYN-SEND 的状态；
2. 服务端 B 收到连接请求报文后，如果同意建立连接，则向 A 发送确认报文段，会报首部中的 SYN 和 ACK 都置为 1，确认号为 x+1，初始化序号为 y。此时服务端进入 SYN-RCVD 的状态；
3. 客户端 A 收到服务端 B 的确认后，向服务端 B 发出确认报文，将首部中的 ACK 和 SYN 置为 1，序号 x+1，确认号 y + 1。此时客户端进入连接状态。服务端 B 收到确认后，也进入连接状态。二者就可以进行数据传输了。

##### 为什么三次握手，两次行不行？

不行，为了防止已失效的连接请求报文段突然传到了 B，因而产生错误。（造成资源浪费）

考虑这么个场景，客户端 A 发一个建立连接报文，中途丢了，客户端 A 一直没有收到服务端 B 确认报文。客户端 A 又重新一个建立连接报文，服务端 B 回了，二者建立连接，传输完数据就释放了。

如果两次握手的话，客户端 A 第一次建立连接报文在网络中停滞了，在完成数据传输并释放后。服务端 B 收到到客户端 A 第一个建立连接报文，则进入连接状态。然而客户端 A 没有数据要传输，从而造成了资源的浪费。

#### 说一说 TCP 的四次挥手？

我先说 TCP 四次挥手过程中，客户端和服务端状态的变化。
客户端状态的变化：连接 -> FIN-WAIT1 -> FIN-WAIT2 -> TIME-WAIT -> CLOSED
服务端状态的变化：连接 -> CLOSE-WAIT -> LAST-ACK -> CLOSED

在这个过程中，会用到首部字段 FIN，用来释放一个连接。在释放连接报文中始终置为 1。

假设客户端 A 和 服务端 B 正连接中，由客户端 A 主动断开连接。

1. 客户端 A 向服务端 B 发送一个释放报文并停止发送数据。首部 FIN 被置为 1，序号为为传输过数据序号的最后一个字节序号 + 1，假设为 u。此时进入了 FIN-WAIT1 的状态；
2. 服务端 B 收到客户端 A 的释放报文后，发出确认报文。首部 ACK 被置为 1，确认号为 u + 1，序号为 B 前面传输数据的最后一个序号 + 1，假设为 w。此时进入了 CLOSE-WAIT 状态。这个状态 A 已经没有数据要发送了，但 B 要发送数据，A 仍要接收；
   客户端 A 收到服务端 B 的确认后，进入FIN-WAIT2 状态，等待服务端 B 发出连接释放报文段；
   若此时服务端 B 没有要向客户端 A 发送数据，则将 FIN 置为 1，确认号为 u + 1，序号假设为 w，发报文给客户端 A，然后进入 LAST-ACK 状态；
3. 客户端 A 收到服务端 B 的确认后，则向服务端 B 发送确认报文，首部的 FIN 置为 1，确认号为 w + 1, 序号为 u+1。此时进入 TIME-WAIT 状态；
4. 服务端 B 在收到客端户 A 的确认后，进入 CLOSE 状态。客户端 A 经过时间等待器设为 2MSL(最长报文段寿命)后，客户端 A 才进入 CLOSED 状态。

##### 客户端为什么要等待 2MSL 时间呢？

两个原因：
为了保证服客户端 A 发送的最后一个 ACK 报文段到服务端 B。这个 ACK 报文可能会丢失，因而使 LAST-ACK 状态的服务端 B 收不到客户端 A 的 FIN + ACK 报文段，服务端会重传 FIN + ACK 报文段，而 A 在 2MSL 时间内收到，接着客户端 A 重传一次确认，重新启动 2MSL 计时器。最后客户端 A 和服务端 B都进入关闭状态。
为了让无效的连接请求在网络中消失，以免影响下一个连接的建立。（三次挥手行不行？的答案）

##### 说一说 TCP 流分段的依据？

TCP 流根据 MSS(最大报文段) 来分的，如果 TCP 不分段的话，IP 层会分段的。当然也会考虑接收方的处理能力。

##### TIME-WAIT 的状态？

保证至少一次报文的往返时间内端口是不可复用的。

tcp_tw_reuse = 1 时，表示作为客户端时，新连接可使用仍然处于 TIME-WAIT 状态的端口。
tcp_timestamp = 1 时，可以拒绝迟到的报文
tcp_recycle = 1 时，表示客户端和服务端都可以复用 TIME-WAIT 状态的端口。
tcp_max_tw_buckets = 1 时，表示 TIME-WAIT 状态端口的数量，如果超出就会立即释放。
tcp_keepalive_time = 7200，表示连接存活时间
tcp_keepalive_intvl = 75。如果没有响应，会隔 75 s 发一次探测
tcp_keepalive_probes = 9。如果探测报重试次数，超了就释放。

#### 说一说滑动窗口？

发送字节流的状态：已发送并收到确认、已发送并未收到确认、允许发送但未发送、不允许发送。

接收字节流的状态：已发送确认并交付主机、允许接收、不允许接收。

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中窗口字段告诉发送方自己的窗口大小，发送方根据这个值来设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送且收到确认，那么就将发送窗口往右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已发送确认并交付主机，就往右滑动。

接收窗口只会对窗内的最后一个按序到达的字节进行确认。

#### 说一说流量控制?

流量控制为了控制发送方发送速率，保证接收方来得及接受。

接收方发送的确认报文中窗口字段可以用来控制发送方窗口大小，从而影响发送方的速率。将窗口字段设置为 0，则发送方不能发送数据。

#### 说一说拥塞控制？

如果网络出现拥塞，分组将丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这个一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

发送方需要维护一个叫做拥塞控制的状态变量，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

1. 慢开始与拥塞控制
   - 发送的最初执行慢开始，令拥塞窗口状态变量为 1，发送方此时只能传 1 个报文段。当收到确认后，拥塞窗口状态变量值翻倍，直到慢开始门限值。
   - 然后执行拥塞控制，拥塞窗口状态变量每次 +1，当发生超时时，则将门限值设为拥塞窗口变量值的一半，再重新执行慢开始。
2. 快重传与快恢复
   - 在接受方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。
   - 在发送方，如果收到三个重复的确认，那么可以知道下一个报文丢失了，此时执行快重传，立即重传下一个报文段。
   - 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令拥塞窗口门限值为变量值的一半。

慢开始和快恢复的快慢是指拥塞控制窗口值的设定值，慢开始是 1，快恢复是拥塞控制参数的门限值。

#### 参考资料

https://github.com/CyC2018/CS-Notes







